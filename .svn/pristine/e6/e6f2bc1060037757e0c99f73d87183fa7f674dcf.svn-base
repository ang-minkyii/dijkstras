DESIGN NOTESpecificationThe OCHA (Office for the Coordination of Humanitarian Affairs) would like to develop a simple way of coordinating the provision of relief supplies as quickly as possible during an emergency situation.TaskDevelop software that will locate the relief centre or centres closest to the site to a disaster.Outline of the ProgramStage 1 - Construct a Graph--------------------------------------------------First a structure consists of city ID, city name, relief, number of neighbours and a double pointer called next. Every line of data input is scanned and the information is inserted into a new structure. At the end of scanning, the number of structure/node will be equal to the number of cities scanned. One important thing to notice, these nodes need to be connected to each other according to the data input. And also, when a line of data is scanned and inserted, its neighbours' city ID and the time taken to reach that particular city is also recorded in another structure containing a pointer to an array and a structure exactly like the previous structure. At the moment, there are two structures, one to store all the city information, another one wrapping these city structure and also an array.The first structure is called the 'city_t'.The second structure is called the 'wrap_t'.They look like this:Struct ajdlistnode{	Int ID;	Char cityname[MAX];	Char relief[MAX];	Link_t **next;	Int num_neighbours;};Typedef struct ajdlistnode city_t;Struct tempnode{	City_t *cityinfo;	Int *travel;}Typedef struct tempnode wrap_t;The Array--------------------------------------------------------------------What this array does is to store the cities this city is connected to. For example, City 1 is connected to city 3 with travel time 20 hours and city 4 with travel time 30 hours. Every slot in the array would initialized to -1 to indicate they are not connected to anything at the moment. Then at the third slot, A [3], it is assigned to 20 and at the fourth slot, A [4], of course, 30. This array stays inside the wrap_t of city 1.The next part of the program - City Link ------------------------------------In this section, there is a function called Citylink. What it does is basically using the arrays of all the cities, and link them accordingly. This time, the next pointer inside the city_t is used to link to other cities. But it is a double pointer because it points to an array of pointers with size according to the number of neighbours this city has. Note that it is a double pointer of another type called link_t because in this type, it has the travel time and a pointer to the next city.After this stage, when all the cities are linked and a graph is constructed.The wrap structure is eliminated left only the city_t structure. It is now a complete and clean graph.Type of Algorithm and Data Structure-----------------------------------------<< Floyd Warshall >>Now we are left to find the shortest path from other cities which have the desired relief to the disaster location. There are quite a few algorithms out there to do the job but each has a different complexity to one another. First let’s look at Floyd Warshall (FW). FW is an easy to code and understand algorithm. It gets the job done and also gives us the shortest path in a weighted graph with positive and negative edge weights and also for finding transitive closure of a relation R. It gives the shortest path and retrieving the path/path reconstruction might costs quite a bit of memory. Its best case performance is in big O of n3 and its worst case is also in omega O of n3. In general, I personally think this is an average algorithm. For a sparse graph, this algorithm is still not as good as Dijkstra's algorithm with a Fibonacci heap or binary heap implementation.And also, for FW to run, it needs an adjacency matrix representation, again which is not very memory efficient. People who would want to code a FW algorithm which I assume, don’t have a memory insufficiency issue. But considering computers or tablets nowadays which run thousands of apps and also multitask which puts a lot of pressure on a poor piece of hardware, good memory allocation and efficiency plays a very important part.<< Dijkstra's Algorithm >>Dijkstra's algorithm is an abstract data structure, it gives us an idea how to use dijsktra's algorithm to find the shortest path from a source to all other nodes. It is merely a concept. There are quite a few implementations out there which is coded based on Dijkstra's data structure, epitome, Linear Array Implementation, Binary Heap and Fibonacci Heap. The computational complexity of each implementation is taken into consideration before setting this program up. First, we will look at the linear array implementation.-------Linear Array Implementation--------------------------------------------This implementation takes advantage of adjacency matrix which is a two dimensional array and iteratively loop through all the data and compute the shortest path. This is the simplest implementation of the Dijkstra's algorithm and is simply a linear search through all the vertices in a graph. In this case, the running time is the big O of n2. -------Binary Heap Implementation---------------------------------------------For sparse graph, dijkstra's algorithm can be implemented more efficiently by storing the graph in the form of adjacency lists and using a binary heap as a priority queue to implement extracting minimum efficiently. In a sorted array of n elements, the average time complexity is O((|V| + |E|)log(n))(Cited from Cletus 24 july 2013 - http://stackoverflow.com/questions/487258/plain-english-explanation-of-big-o) and similar for worse case performance. This is obviously more efficient than the linear array implementation in most cases.A graph sometimes carries negative weights, in this case, a normal dijkstra's algorithm wouldn't work and a work-around is required to solve the problem. Here's comes Bellman-Ford algorithm. But also, in this problem, we can assume there wouldn't not be any negative time taken to travel from one city to another. Thus, implementing Bellman-Ford is redundant and unnecessary.A binary heap implementation of dijkstra's algorithm will be enough.-------Fibonacci Heap Implementation------------------------------------------This is a very powerful data structure and is in general not as expensive as binary heap. A common binary heap, where every node has at most two children, must both have a lesser key value. For Fibonacci heap, we rejected this restriction. So every node can have any number of children and there exists no single root element but a list of roots, whereas the root with the minimum key is distinguished by a head pointer. If the underlying graph is dense, Fibonacci heap is the most efficient way of finding the shortest route. But under normal circumstances, depending on who coded it, it could suffer performance-wise. After some research, Fibonacci heaps only outperformed binary heap when the graph is incredibly large and dense. And in other cases, Fibonacci heap and binary heap perform about the same, with Fibonacci heap usually outperforming by an insignificant amount. (Peter Alexander - 22 September 2010 - http://stackoverflow.com/questions/3767863/real-world-applications-of-binary-heaps-and-fibonacci-heaps)This implementation hasn't been taught in class and also trying to understand it could take some time. Since both implementation perform about the same, binary heap implementation is more preferable in this case because binary heap which has been taught in this subject is more coding friendly and understand-able to most people.My choice of Data Structure: Dijkstra's Algorithm with Binary Heap Implementation. -----------------------------------------------------------------------------Now back to the problem, I already have a complete and connected graph implemented with adjacency lists (of course with pointers flying around all over the code), a binary heap implementation is chosen to find the shortest path and reconstruct the path taken from other cities to the disaster location. User is prompt to input the disaster location and the code will automatically scan the cityname inserted and return the city ID of the disaster location. One important point at this stage, dijkstra's algorithm finds the shortest path FROM the source to every OTHER nodes. What I was instructed to do is to find the shortest path FROM other cities to the DISASTER LOCATION. This makes the problem a little bit tricky. After considering all the possibilities, I figured the best way to overcome this dilemma is to flip the graph around, with directions flipped. For example, traveling from city 1 to city 2 takes 20 hours and coming back takes 24 hours. What dijkstra's algorithm would find is 20 hours with the graph not flipped. What we actually intended to find is 24 hours which is the coming back time. Thus, after flipping the directions, dijkstra's algorithm would give a shortest path of 24 hours. Perfect.So, a function called graphflipper was created, which flipped all the directions and dijkstra's algorithm was applied to find the shortest path.NEXT:Path Reconstruction-----------------------------------------------------------After finding the shortest path, retrieving the path taken is easy. An array is initialized and malloc-ed and returned by dijkstra's function. What this array does is actually just recording the parent of each node visited only if this is the shortest path possible. For example, an array that looks like this:A[0] = 24726374A[1] = -1A[2] = 1A[3] = 2A[4] = 024726374 = INT_MAX (only applied to this example);The path taken from city 3 to 1 is simply 3 to 2 and 2 to 1. The path stops when the value of the array is either INT_MAX or -1(because no city would have ID -1 or INT_MAX). Note: City 4 would go to city 0 and hit INT_MAX which simply means City 0 and 4 can't get to City 1.Note: This array is called parents[] in my code.Desired Relief----------------------------------------------------------------Here, user is prompt to enter the desired relief/supply. The available supplies are stated in the specification. If other relief is entered and isn't in the available list, the program would simply say the relief type is not available/relief type unknown. If the user entered an 'X', the program would output all the assistances available from the closest cities. Choosing the shortest path----------------------------------------------------Besides, parents [], what dijkstra's function would return is another array called dist[]. Dist[] is an array which stores the shortest distance from disaster location to other cities (with the graph flipped). This array is used to choose the closest city with desired relief to the disaster location because there might be a number of cities with supply which can get to the disaster location, the closest one has to be chosen.Additional Information-------------------------------------------------------Filename and also the city name entered are restricted to a number of characters at 256. If users input more than 256 characters, the program would exit to prevent buffer overflow. This is also commonly known as buffer overflow attack. Makefile---------------------------------------------------------------------The program is split into a number of files, namely, binheap.h, binheap.c, graph.h, graph.c, helpme.h, and helpme.c.Binheap.h and binheap.c contain all the information and functions of the binary heap operation.Graph.h and graph.c contain the functions to construct the graph initially and also dijkstra's algorithm to find the shortest path.Helpme.c and helpme.h are simply the main function and header file.Further Implementation-------------------------------------------------------A further/better implementation would be Fibonacci Heap. Most of binary operations are O(log n) but for fibonacci heap, all the operations are in O(1) except deletemin/extractmin. References-------------------------------------------------------------------www.stackoverflow.comwww.geeksforgeeks.comwww.tutorialspoint.comwww.bigocheatsheet.com- Lecture notes from the subject COMP20003 – University of MelbourneStudent Name : Ang Mink YiiStudent ID : 565604Univeristy of MelbourneTutorial time : 2:15pm Thursday